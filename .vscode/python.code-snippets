{
  "input().split()": {
    "scope": "python",
    "prefix": "input().split()",
    "body": "input().split()"
  },
  "map(int,input().split())": {
    "scope": "python",
    "prefix": "map(int,input().split())",
    "body": "map(int,input().split())"
  },
  "[*map(int,input().split())]": {
    "scope": "python",
    "prefix": "list(map(int,input().split()))",
    "body": "[*map(int,input().split())]"
  },
  "nested loop double": {
    "scope": "python",
    "prefix": "forfor",
    "body": ["for i in range(${1:}):", "\tfor j in range(${2:}):", "\t\t"]
  },
  "nested loop triple": {
    "scope": "python",
    "prefix": "forforfor",
    "body": [
      "for i in range(${1:}):",
      "\tfor j in range(${2:}):",
      "\t\tfor k in range(${3:}):",
      "\t\t\t"
    ]
  },
  "int(input())": {
    "scope": "python",
    "prefix": "int(input())",
    "body": "int(input())"
  },
  "enumerate()": {
    "scope": "python",
    "prefix": "enumerate",
    "body": "enumerate(${1:})"
  },
  "input()": {
    "scope": "python",
    "prefix": "input()",
    "body": "input()"
  },
  "map(int,open(0))": {
    "scope": "python",
    "prefix": "map(int,open(0))",
    "body": "map(int,open(0))"
  },
  "map(int,open(0).read().split())": {
    "scope": "python",
    "prefix": "map(int,open(0).read().split())",
    "body": "map(int,open(0).read().split())"
  },
  "class DSU:": {
    "scope": "python",
    "prefix": "class DSU:",
    "body": [
      "# Disjoint Set Union library",
      "class DSU:",
      "\tdef __init__(self, n):",
      "\t\tself.n = n",
      "\t\tself.parent = [-1] * n",
      "",
      "\tdef root(self, x):",
      "\t\tif self.parent[x] < 0:",
      "\t\t\treturn x",
      "\t\tself.parent[x] = self.root(self.parent[x])",
      "\t\treturn self.parent[x]",
      "",
      "\tdef merge(self, x, y):",
      "\t\trx = self.root(x)",
      "\t\try = self.root(y)",
      "\t\tif rx == ry:",
      "\t\t\treturn",
      "\t\tif rx > ry:",
      "\t\t\trx, ry = ry, rx",
      "\t\tself.parent[rx] += self.parent[ry]",
      "\t\tself.parent[ry] = rx",
      "",
      "\tdef size(self, x):",
      "\t\treturn -self.parent[self.root(x)]",
      "",
      "\tdef connected(self, x, y):",
      "\t\treturn self.root(x) == self.root(y)",
      "",
      "\tdef members(self):",
      "\t\tmembers = {}",
      "\t\tfor i in range(self.n):",
      "\t\t\tkey = self.root(i)",
      "\t\t\tif key in members:",
      "\t\t\t\tmembers[key].append(i)",
      "\t\t\telse:",
      "\t\t\t\tmembers[key] = [i]",
      "\t\treturn members.values()"
    ],
    "description": "Union Find Tree"
  },
  "class Kruskal:": {
    "scope": "python",
    "prefix": "class Kruskal:",
    "body": [
      "# Kruskal's algorithm library",
      "class DSU:",
      "\tdef __init__(self,n):",
      "\t\tself.parent=[-1]*n",
      "\tdef root(self,x):",
      "\t\tif self.parent[x]<0:return x",
      "\t\tself.parent[x]=self.root(self.parent[x])",
      "\t\treturn self.parent[x]",
      "\tdef merge(self,x,y):",
      "\t\trx=self.root(x)",
      "\t\try=self.root(y)",
      "\t\tif rx==ry:return",
      "\t\tif rx>ry:rx,ry=ry,rx",
      "\t\tself.parent[rx]+=self.parent[ry]",
      "\t\tself.parent[ry]=rx",
      "\tdef size(self,x):",
      "\t\treturn -self.parent[self.root(x)]",
      "\tdef connected(self,x,y):",
      "\t\treturn self.root(x)==self.root(y)",
      "",
      "class Edge:",
      "\tdef __init__(self,u,v,cost):",
      "\t\tself.u=u",
      "\t\tself.v=v",
      "\t\tself.cost=cost",
      "",
      "class Kruskal:",
      "\tdef __init__(self,vertex_count,edges):",
      "\t\tself.edges=edges",
      "\t\tself.vertex_count=vertex_count",
      "\tdef calc(self):",
      "\t\tself.edges.sort(key=lambda e:e.cost)",
      "\t\tdsu=DSU(self.vertex_count)",
      "\t\ttotal=0",
      "\t\tfor e in self.edges:",
      "\t\t\tif not dsu.connected(e.u,e.v):",
      "\t\t\t\tdsu.merge(e.u,e.v)",
      "\t\t\t\ttotal+=e.cost",
      "\t\treturn total",
      "# Kruskal's algorithm library",
      ""
    ],
    "description": "Kruskal algorithm"
  },
  "factorial inverse": {
    "scope": "python",
    "prefix": "fact_inv",
    "body": [
      "# Factorial Inverse library",
      "MAX_N = ${1:}",
      "MOD = 10 ** 9 + 7",
      "fact = [1] * (MAX_N + 1)",
      "inv = fact.copy()",
      "fact_inv = fact.copy()",
      "",
      "for i in range(2, MAX_N + 1):",
      "\tfact[i] = fact[i - 1] * i % MOD",
      "\tinv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD",
      "\tfact_inv[i] = fact_inv[i - 1] * inv[i] % MOD"
    ],
    "description": "for binomial coefficient"
  },
  "for _ in range(n)": {
    "scope": "python",
    "prefix": "for _ in range(n)",
    "body": ["for _ in range(n)"]
  },
  "Warshall-Floyed algorithm": {
    "scope": "python",
    "prefix": "Warshall-Floyed algorithm",
    "body": [
      "# Warshall-Floyed Alogrithm",
      "# n: vertex_count",
      "# cost[i][j]: cost from i to j",
      "INF = 1 << 60",
      "cost = [[INF] * n for _ in range(n)]",
      "# --- INPUT COST OF EDGES HERE---",
      "${1:}",
      "# --- INPUT COST OF EDGES HERE---",
      "for k in range(n):",
      "\tfor i in range(n):",
      "\t\tfor j in range(n):",
      "\t\t\tif cost[i][k] != INF and cost[k][j] != INF:",
      "\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])"
    ]
  },
  "zeta transform": {
    "scope": "python",
    "prefix": "zeta_transform",
    "body": [
      "def zeta_transform(l):",
      "\tfor i in range(1, len(l)):",
      "\t\tl[i] += l[i - 1]",
      "\treturn l",
      ""
    ]
  },
  "mobius transform": {
    "scope": "python",
    "prefix": "mobius_transform",
    "body": [
      "def mobius_transform(l):",
      "\tfor i in range(len(l) - 1, 0, -1):",
      "\t\tl[i] -= l[i - 1]",
      "\treturn l",
      ""
    ]
  },
  "yates function": {
    "scope": "python",
    "prefix": "yates_function",
    "body": [
      "def yates_function(l, h, w):",
      "\tfor i in range(h):",
      "\t\tfor j in range(w):",
      "\t\t\tif i:",
      "\t\t\t\tl[i][j] += l[i - 1][j]",
      "\tfor i in range(h):",
      "\t\tfor j in range(w):",
      "\t\t\tif j:",
      "\t\t\t\tl[i][j] += l[i][j - 1]",
      "\treturn l",
      ""
    ]
  },
  "cumulative sum 2d": {
    "scope": "python",
    "prefix": "CumulativeSum2d",
    "body": [
      "class CumulativeSum2D:",
      "\tdef __init__(self, h, w):",
      "\t\tself.h = h + 1",
      "\t\tself.w = w + 1",
      "\t\tself.table = [[0] * self.w for _ in range(self.h)]",
      "",
      "\tdef add(self, i, j, x):",
      "\t\tself.table[i + 1][j + 1] += x",
      "",
      "\tdef build(self):",
      "\t\tfor i in range(self.h):",
      "\t\t\tfor j in range(self.w):",
      "\t\t\t\tif i:",
      "\t\t\t\t\tself.table[i][j] += self.table[i - 1][j]",
      "\t\tfor i in range(self.h):",
      "\t\t\tfor j in range(self.w):",
      "\t\t\t\tif j:",
      "\t\t\t\t\tself.table[i][j] += self.table[i][j - 1]",
      "",
      "\tdef get(self, i1, j1, i2, j2):",
      "\t\treturn (",
      "\t\t\tself.table[i2][j2]",
      "\t\t\t- self.table[i2][j1]",
      "\t\t\t- self.table[i1][j2]",
      "\t\t\t+ self.table[i1][j1]",
      "\t\t)",
      ""
    ]
  },
  "BIT": {
    "scope": "python",
    "prefix": "BinaryIndexedTree",
    "body": [
      "class BinaryIndexedTree:",
      "\tdef __init__(self, n):",
      "\t\tself.size = n",
      "\t\tself.tree = [0] * (n + 1)",
      "",
      "\tdef sum(self, i):",
      "\t\ttotal = 0",
      "\t\twhile i:",
      "\t\t\ttotal += self.tree[i]",
      "\t\t\ti -= i & -i",
      "\t\treturn total",
      "",
      "\tdef add(self, i, x):",
      "\t\twhile i <= self.size:",
      "\t\t\tself.tree[i] += x",
      "\t\t\ti += i & -i",
      ""
    ]
  },
  "FenwickTree": {
    "scope": "python",
    "prefix": "FenwickTree",
    "body": [
      "class FenwickTree:",
      "\tdef __init__(self, n, identity_factory, func):",
      "\t\tself.size = n",
      "\t\tself.tree = [identity_factory() for _ in range(n + 1)]",
      "\t\tself.func = func",
      "\t\tself.idf = identity_factory",
      "",
      "\tdef add(self, i, x):",
      "\t\ttree = self.tree",
      "\t\tfunc = self.func",
      "\t\twhile i <= self.size:",
      "\t\t\ttree[i] = func(tree[i], x)",
      "\t\t\ti += i & -i",
      "",
      "\tdef sum(self, i):",
      "\t\ts = self.idf()",
      "\t\ttree = self.tree",
      "\t\tfunc = self.func",
      "\t\twhile i > 0:",
      "\t\t\ts = func(s, tree[i])",
      "\t\t\ti -= i & -i",
      "\t\treturn s",
      ""
    ]
  },
  "Dijkstra": {
    "scope": "python",
    "prefix": "class Dijkstra:",
    "body": [
      "from collections import defaultdict",
      "from heapq import heappush, heappop",
      "",
      "",
      "class Dijkstra:",
      "\tdef __init__(self, size):",
      "\t\tself.edges = defaultdict(list)",
      "\t\tself.size = size  # number of nodes",
      "",
      "\tdef add(self, a, b, cost):",
      "\t\tself.edges[a].append((b, cost))",
      "",
      "\tdef calc(self, start):",
      "\t\tdist = [1 << 60] * self.size",
      "\t\tdist[start] = 0",
      "\t\tq = []",
      "\t\theappush(q, (0, start))",
      "\t\twhile q:",
      "\t\t\tpre_cost, pre_index = heappop(q)",
      "\t\t\tfor nxt_index, nxt_cost in self.edges[pre_index]:",
      "\t\t\t\tcost = pre_cost + nxt_cost",
      "\t\t\t\tif cost < dist[nxt_index]:",
      "\t\t\t\t\theappush(q, (cost, nxt_index))",
      "\t\t\t\t\tdist[nxt_index] = cost",
      "\t\treturn dist",
      "",
      ""
    ]
  }
}
